syntax = "proto3";

package secureagg;

// TTP Service - Distributes signing keys to participants
service TTPService {
  rpc RegisterNode(RegisterRequest) returns (RegisterResponse);
  rpc GetParticipants(ParticipantsRequest) returns (ParticipantsResponse);
}

message RegisterRequest {
  string node_id = 1;
  string address = 2;
}

message RegisterResponse {
  bytes signing_private_key = 1;  // Ed25519 private key
  bytes signing_public_key = 2;   // Ed25519 public key
  bool success = 3;
  string message = 4;
  // Clique assignment from topology
  int32 clique_id = 5;
  repeated string clique_members = 6;
  int32 clique_threshold = 7;
  repeated int32 data_indices = 8;  // Assigned data indices for this node
  string central_metadata_data_id = 9;
  int32 central_metadata_version = 10;
}

message ParticipantsRequest {}

message ParticipantsResponse {
  repeated NodeInfo participants = 1;
}

message NodeInfo {
  string node_id = 1;
  string address = 2;
  bytes signing_public_key = 3;
}

// Aggregator Service - Coordinates secure aggregation rounds
service AggregatorService {
  rpc Round0AdvertiseKeys(KeyAdvertisement) returns (KeyAdvertisementAck);
  rpc Round1ShareKeys(ShareKeysMessage) returns (ShareKeysAck);
  rpc Round2MaskedInput(MaskedInputMessage) returns (MaskedInputAck);
  rpc Round3ConsistencyCheck(ConsistencySignature) returns (ConsistencyAck);
  rpc Round4Unmask(UnmaskShares) returns (UnmaskAck);
  rpc GetGlobalModel(ModelRequest) returns (ModelResponse);
  // Bridge nodes forward ECMs to aggregator for inter-cluster merge
  rpc SubmitECMs(ECMSubmitRequest) returns (ECMSubmitResponse);
  // Clique members can notify the aggregator when convergence is confirmed.
  rpc NotifyConvergenceSignal(ConvergenceSignal) returns (ConvergenceAck);
}

// Round 0: Advertise DH public keys
message KeyAdvertisement {
  string node_id = 1;
  bytes c_public_key = 2;  // ECDH public key for encryption
  bytes s_public_key = 3;  // ECDH public key for masking
  bytes signature = 4;     // Signature over (c_PK || s_PK)
}

message KeyAdvertisementAck {
  bool accepted = 1;
  string message = 2;
  repeated KeyAdvertisement all_keys = 3;  // Broadcast U1 list
}

// Round 1: Share encrypted secrets
message ShareKeysMessage {
  string node_id = 1;
  repeated Round1Ciphertext ciphertexts = 2;
}

message ShareKeysAck {
  bool accepted = 1;
  string message = 2;
  repeated Round1Ciphertext mailbox = 3;
}

// Round 1 ciphertext (per recipient)
message Round1Ciphertext {
  string sender_id = 1;
  string recipient_id = 2;
  bytes iv = 3;
  bytes ciphertext = 4;
  bytes tag = 5;
}

// Round 2: Masked model update
message MaskedInputMessage {
  string node_id = 1;
  repeated bytes masked_vector = 2;  // Quantized + masked model params (big-endian)
}

message MaskedInputAck {
  bool accepted = 1;
  string message = 2;
  repeated string survivors = 3;  // U3 list
}

// Round 3: Consistency signatures
message ConsistencySignature {
  string node_id = 1;
  bytes signature = 2;  // Sign(d_SK, U3)
}

message ConsistencyAck {
  bool accepted = 1;
  string message = 2;
}

// Round 4: Unmask shares
message UnmaskShares {
  string node_id = 1;
  map<string, bytes> dropout_s_shares = 2;   // dropout_id -> s_SK share
  map<string, bytes> survivor_b_shares = 3;  // survivor_id -> b seed share
}

message UnmaskAck {
  bool accepted = 1;
  string message = 2;
  bool aggregation_complete = 3;
}

// Model distribution
message ModelRequest {
  int32 round = 1;
}

message ModelResponse {
  repeated float model_weights = 1;
  int32 round = 2;
  string aggregator_id = 3;
  // Convergence signaling fields
  bool should_stop = 4;
  string stop_reason = 5;
  float delta_norm = 6;
  bool cluster_converged = 7;
  int32 convergence_streak = 11;
  bool metadata_ready = 12;
  // IPFS reference for merged model (nodes fetch from IPFS if set)
  string model_cid = 8;
  string model_hash = 9;
  string model_data_id = 10;
}

// Inter-cluster ECM (External Cluster Model) messages
message ECMMessage {
  string cid = 1;           // IPFS content identifier
  string hash = 2;          // SHA256 hash for verification
  string source_cluster = 3; // Origin cluster ID
}

message ECMSubmitRequest {
  string node_id = 1;
  repeated ECMMessage ecms = 2;  // ECMs from neighbor clusters
}

message ECMSubmitResponse {
  bool accepted = 1;
  string message = 2;
}

message ECMBroadcast {
  string cluster_id = 1;
  int32 round = 2;
  string cid = 3;
  string hash = 4;
  // Convergence status for cross-cluster coordination
  bool cluster_converged = 5;
  float cluster_delta_norm = 6;
  string convergence_data_id = 7;
}

message ConvergenceSignal {
  string data_id = 1;
  int32 round = 2;
}

message ConvergenceAck {
  bool accepted = 1;
  string message = 2;
}

// Bridge node service for inter-cluster ECM gossip
service BridgeService {
  rpc SubmitECMs(ECMSubmitRequest) returns (ECMSubmitResponse);
  rpc ReceiveECM(ECMBroadcast) returns (ECMSubmitResponse);
}
